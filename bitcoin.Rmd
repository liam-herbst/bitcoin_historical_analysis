---
title: "Bitcoin Price Prediction"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: united
---
### Import Libaries
```{r}
# All coin history data was sourced from [Crypto Download Data](https://www.cryptodatadownload.com/)
library(ggplot2)
library(dplyr)
library(devtools)
library(plotly)
library(rpart)
library(randomForest)
library(quantmod)
library(xts)
library(coinmarketcapr)
library(tidyverse)
library(PerformanceAnalytics)
```

# Evaluating Bitcoin
## Clean & Read Historical Data
```{r}
# Read CSV data into R
btc_data <- read.csv("Coinbase_BTCUSD_d.csv", header = TRUE)
# Display the first 6 elements to ensure that the data is read
head(btc_data)
```
```{r}
# Order rows by date
btc = btc_data[order(btc_data$Date),]
head(btc)
```

```{r}
# Remove Symbol
btc = subset(btc, select = -c(Timestamp, Symbol))
# Check
head(btc)
```
```{r}
# Convert Date factor into date format
btc$Date <- as.Date(btc$Date, format = "%Y-%m-%d")
head(btc)
```
No irregularities to correct. The substantial variance between prices is due to Bitcoin's rapid ascent in price over the duration of the dataset. As shown in the next section.
## Create y variable: close price of next day 

```{r}
#btc$Close.nextday = 0
#test_var <- btc$Close
#column_data_close_price <- 0


#for(i in 1:length(test_var)) {
  #column_data_close_price[i] <- test_var[i+1]
#}
#btc$Close.nextday = column_data_close_price

#btc
```
## Add Binary Close Variable
```{r}
btc$HL.Close = 0 
test_var <- btc$Close
column_data_close_HL <- 0

for(i in 1:length(test_var)) {
  
  if(isTRUE(test_var[i] > test_var[i+1])) {
    column_data_close_HL[i] <- "L"
  }
  else if(isTRUE(test_var[i] == test_var[i+1])) {
    column_data_close_HL[i] <- "L"
  }
  else{
    column_data_close_HL[i] <- "H"
  }
}

btc$HL.Close = column_data_close_HL
p <- btc$HL.Close

head(btc)
```
```{r}
btc <- btc[-c(2170), ]
length(btc$Date)
``` 
## Historical Price Chart
```{r}
ds <- data.frame(Date = btc$Date, btc$Close, btc$Volume.USD)

ay <- list(
  tickfont = list(color = "Orange"),
  overlaying = "y",
  side = "right",
  title = "Trade Volume"
)
fig <- plot_ly(ds, x = ~Date)
fig <- fig %>% add_lines(y = ~btc$Close, name = "Price")
fig <- fig %>% add_lines(y = ~btc$Volume.USD, name = "Volume", yaxis = "y2")
fig <- fig %>% layout(
    title = "Bitcoin Price & Trade Volume",
    yaxis2 = ay,
    xaxis = list(
      rangeselector = list(
        buttons = list(
          list(
            count = 3,
            label = "3 mo",
            step = "month",
            stepmode = "backward"),
          list(
            count = 6,
            label = "6 mo",
            step = "month",
            stepmode = "backward"),
          list(
            count = 1,
            label = "1 yr",
            step = "year",
            stepmode = "backward"),
          list(
            count = 1,
            label = "YTD",
            step = "year",
            stepmode = "todate"),
          list(step = "all"))),
      rangeslider = list(type = "date")),
    yaxis = list(
      title = "Price (USD)",
      tickfont = list(color = "Black"))
)
fig
```
## Display 2014-2020 Summary Figures
```{r}
summary(btc)
```
## Display Scatter Plots & Find Correlations
```{r}
btc_cor <- btc[, 2:7]
chart.Correlation(btc_cor)
```
In the above plot:

- The distribution of each variable is shown on the diagonal.
- On the bottom of the diagonal : the bivariate scatter plots with a fitted line are displayed
- On the top of the diagonal : the value of the correlation plus the significance level as stars
- Each significance level is associated to a symbol : p-values(0, 0.001, 0.01, 0.05, 0.1, 1) <=> symbols(“***”, “**”, “*”, “.”, " “)

These graphs show us that there is very little difference between the 'Open', 'High', 'Low', and 'Close' figures, so we are only going to remove all but the 'Close' variable and retest.
```{r}
# Remove the Open, High and Low variables
btc <- subset(btc, select = -c(Open, High, Low))
# Rename Close variable to Price
names(btc)[names(btc) == "Close"] <- "Price"
# Check 
head(btc)
```
```{r}
# Re-run correlation matrix &^ scatter plots
btc_cor <- btc[, 2:4]
chart.Correlation(btc_cor)
```
- The strongest linear relationship is between Volume.BTC and Volume.USD—as shown by the straight diagonal line and correlation of 0.77.

- The correlation between Price and Volume.USD is also high at 0.7 but the correlation between Price and Volume.BTC is just inside the ideal threshold of < 0.4 or > -0.4 at 0.35. Since Volume.BTC it is the only x-variable that has a correlation inside the ideal threshold and it's with the y-variable we're trying to predict—Bitcoin-further evaluation will be needed with additional data sets to run a linear regression and more advanced data science methods for predicting the price of Bitcoin.

- All values have a p-value of ~0 (as represented by the ***) which means they are have a significant difference which isn't caused by chance

## Decision Trees
### Read the data and split into training and testing sets
```{r}
num_samples = dim(btc)[1]
sampling.rate = 0.8
training <- sample(1:num_samples, sampling.rate * num_samples, replace=FALSE)
trainingSet <- subset(btc[training, ])
testing <- setdiff(1:num_samples,training)
testingSet <- subset(btc[testing, ])
```


```{r}
head(trainingSet)
```
Fit a decision tree to predict sales using all the other variables. Note that train the tree using the Training set data
```{r}
#Fit a decision tree model using the training data
decTreeModel <- rpart(HL.Close ~ .,data=trainingSet)
```
Display the tree
```{r}
plot(decTreeModel, margin=0.1)
text(decTreeModel)
```
Leaving the tree size free leads to overfitting. Tune the size by looking at the relative error and the complexity parameter (CP)
```{r}
plotcp(decTreeModel)
```
Prune tree --> but kinda whack so not pruning 
Evaluate the decision tree model using the testing set
```{r}
# Perform prdictions for the testing set
predictedLabels<-predict(decTreeModel, testingSet, type = "class")
print(predictedLabels)
```
Show the true labels
```{r}
print(testingSet$HL.Close)
```

```{r}
# Get the number of data points in the test set
sizeTestSet = dim(testingSet)[1]
# Get the number of data points that are misclassified
error = sum(predictedLabels != testingSet$HL.Close)
# Calculate the misclassification rate
misclassification_rate = error/sizeTestSet
# Display the misclassification rate
print(misclassification_rate)
```
Very bad 
# Random Forest for categorical variables
```{r}
btc$HL.Close <- as.factor(btc$HL.Close)
```
## Create Training and Testing sets 
(Note that this data set is small so let us keep 90% for training)
```{r}
# Create Training and Testing Sets
num_samples = dim(btc)[1]
sampling.rate = 0.9
training <- sample(1:num_samples, sampling.rate * num_samples, replace=FALSE)
trainingSet <- btc[training, ]
testing <- setdiff(1:num_samples,training)
testingSet <- btc[testing, ]
```
Train a random forest using the training set data
```{r}
RandForestModel <- randomForest(HL.Close ~ ., data = trainingSet)
```
Plot the error as a function of the number of trees
```{r}
plot(RandForestModel)
legend("top", colnames(RandForestModel$err.rate),fill=1:3)
```


```{r}
# Perform predictions for the testing set
predictedLabels<-predict(RandForestModel, testingSet)
predictedLabels
```


To evaluate the model, we compute a misclassification rate (the rate of incorrect predictions). Note that in this case we do not calculate MSE since the predictions are categories and not continous values


```{r}
# Get the number of data points in the test set
sizeTestSet = dim(testingSet)[1]
# Get the number of data points that are misclassified
error = sum(predictedLabels != testingSet$HL.Close)
# Calculate the misclassification rate
misclassification_rate = error/sizeTestSet
# Display the misclassification rate
print(misclassification_rate)
```

```{r}
# Get the number of data points in the test set
sizeTestSet = dim(testingSet)[1]
# Get the data points that are misclassified
IsWrong = (predictedLabels != testingSet$HL.Close)
# Get the data points that are classified as L
IsL = (predictedLabels == 'L')
# Get the data points that are misclassified and are classified as L
IsWrongAndL = (IsWrong & IsL)
error = sum(IsWrongAndL)

# Calculate the misclassification rate
misclassification_rate = error/sizeTestSet
# Display the misclassification rate
print(misclassification_rate)
```










------------------------------------------
SPLIT POINT
------------------------------------------







# Bitcoin to Google Search Interest
## Add Google Search Data
```{r}
# Sourced from https://trends.google.com/trends/explore?date=2014-12-01%202020-11-20&geo=US&q=Bitcoin
# Read CSV data into R
search <- read.csv("btc_search_volume.csv", header = TRUE)
# Convert Date factor into date format
search$Date <- as.Date(search$Date, format = "%Y-%m-%d")
# Remove last few rows to align with the btc dataset
search <- search[-c(260:261),]
# Display the first and last 6 elements to ensure that the data is read properly
head(search)
tail(search)
```
### Display Google Search Volume Summary
```{r}
summary(search)
```
## Format BTC Database
```{r}
# Remove first few rows to align with the search dataset
btc_w <- btc[-c(1:370),]
# Remove last few rows to align with the search dataset
head(btc_w)
# Convert to weekly by only pulling the 7th row
btc_w <- btc_w[seq(1, nrow(btc_w), 7),]
head(btc_w)
tail(btc_w)
```
### Combine BTC Weekly and Google Search Data
```{r}
btc_search <- data.frame(btc_w, Volume.Search = search$Volume)
# Check
head(btc_search)
```
## Create Dual Y-Axis Comparable Graph
```{r}
ds <- data.frame(Date = btc_search$Date, btc_search$Price, btc_search$Volume.Search)

ay <- list(
  tickfont = list(color = "Orange"),
  overlaying = "y",
  side = "right",
  title = "Weighted Search Volume"
)
fig <- plot_ly(ds, x = ~Date)
fig <- fig %>% add_lines(x = ~Date, y = ~btc_search$Price, name = "Bitcoin")
fig <- fig %>% add_lines(y = ~btc_search$Volume.Search, name = "Google Search", yaxis = "y2")
fig <- fig %>% layout(
    title = "Bitcoin Price vs. Google Search Volume", 
    yaxis2 = ay,
    xaxis = list(
      rangeselector = list(
        buttons = list(
          list(
            count = 3,
            label = "3 mo",
            step = "month",
            stepmode = "backward"),
          list(
            count = 6,
            label = "6 mo",
            step = "month",
            stepmode = "backward"),
          list(
            count = 1,
            label = "1 yr",
            step = "year",
            stepmode = "backward"),
          list(
            count = 1,
            label = "YTD",
            step = "year",
            stepmode = "todate"),
          list(step = "all"))),
      rangeslider = list(type = "date")),
    yaxis = list(title = "Price (USD)")
  )
fig
```
## Display Scatter Plots & Find Correlations
```{r}
##### This is causing an error because the HIGH/LOW needs to be converted to a binary numerical variable
btc_search_cor <- btc_search[, c(2:5)]
chart.Correlation(btc_search_cor)
```
All correlations are above the 0.4 threshold so I am going to remove the highest (Volume.USD) and run again.
```{r}
btc_search_cor <- btc_search[, c(2,3,5)]
chart.Correlation(btc_search_cor)
```
The Volume.Search variable is still above the 0.4 threshold which'd bring us back to the original correlation matrix above (btc variables only). We can infer further evaluation is needed to predict the price of Bitcoin.

# Compare Cryptocurrencies
For simplicity, I am representing the price with the 'Close' variable and eliminating 'Open', 'High', and 'Low', for all cryptocurrencies and future finanical x.

## Format Coin Data
### Bitcion Data
```{r}
# Rename Close variable to Price
names(btc)[names(btc) == "Price"] <- "BTC.Price"
# Remove Volume. BTC
btc = subset(btc, select = -c(Volume.BTC))
# Rename Volume.USD to Currency
names(btc)[names(btc) == "Volume.USD"] <- "BTC.Volume"
head(btc)
```
### Ethereum Data
```{r}
# Read CSV data into R
eth <- read.csv("Coinbase_ETHUSD_d.csv", header = TRUE)
# Order rows by date
eth = eth_data[order(eth_data$Date),]
# Remove Timestamp & Symbol
eth = subset(eth, select = -c(Unix.Timestamp, Symbol))
# Convert Date factor in date format
eth$Date <- as.Date(eth$Date, format = "%Y-%m-%d")
# Remove the Open, High and Low variables
eth <- subset(eth, select = -c(Open, High, Low, Volume.ETH))
# Rename Close variable to Price
names(eth)[names(eth) == "Close"] <- "ETH.Price"
# Rename Volume.USD to Currency
names(eth)[names(eth) == "Volume.USD"] <- "ETH.Volume"
# Display the first 6 elements to ensure that the data is read properly
head(eth)
```
### Litecoin Data
```{r}
# Read CSV data into R
ltc_data <- read.csv("Coinbase_LTCUSD_d.csv", header = TRUE)
# Order rows by date
ltc = ltc_data[order(ltc_data$Date),]
# Remove Timestamp & Symbol
ltc = subset(ltc, select = -c(Unix.Timestamp, Symbol))
# Convert Date factor into date format
ltc$Date <- as.Date(ltc$Date, format = "%Y-%m-%d")
# Remove the Open, High and Low variables
ltc <- subset(ltc, select = -c(Open, High, Low, Volume.LTC))
# Rename Close variable to Price
names(ltc)[names(ltc) == "Close"] <- "LTC.Price"
# Rename Volume.USD to Currency
names(ltc)[names(ltc) == "Volume.USD"] <- "LTC.Volume"
# Display the first 6 elements to ensure that the data is read properly
head(ltc)
```
### Ripple Data
```{r}
# Read CSV data into R
xrp_data <- read.csv("Bitstamp_XRPUSD_d.csv", header = TRUE)
# Order rows by date
xrp = xrp_data[order(xrp_data$Date),]
# Remove Timestamp & Symbol
xrp = subset(xrp, select = -c(Unix.Timestamp, Symbol))
# Convert Date factor into date format
xrp$Date <- as.Date(xrp$Date, format = "%Y-%m-%d")
# Remove the Open, High and Low variables
xrp <- subset(xrp, select = -c(Open, High, Low, Volume.XRP))
# Rename Close variable to Price
names(xrp)[names(xrp) == "Close"] <- "XRP.Price"
# Rename Volume.USD to Currency
names(xrp)[names(xrp) == "Volume.USD"] <- "XRP.Volume"
# Display the first 6 elements to ensure that the data is read properly
head(xrp)
```
## Filter Rows for Consistency
```{r}
# Total number of rows (from XRP database since it has the fewest historical data points)
c_rows <- 1392
# Format Bitcoin
btc_c <- tail(btc,n=c_rows)
head(btc_c)
# Ethereum
eth <- tail(eth,n=c_rows)
head(eth)
# Litecoin
ltc <- tail(ltc,n=c_rows)
head(ltc)
# Ripple
xrp <- tail(xrp,n=c_rows)
head(xrp)
```
## Remove All but One Date Variable & Merge Datasets
```{r}
# Ethereum
eth <- subset(eth, select = -c(Date))
# Litecoin
ltc <- subset(ltc, select = -c(Date))
# Ripple
xrp <- subset(xrp, select = -c(Date))
# Merge the Data Frames
coins <- cbind(btc_c, eth, ltc, xrp)
head(coins)
```
## Display Scatter Plots & Find Correlations
```{r}
coins_cor <- coins[, 2:9]
chart.Correlation(coins_cor)
```
As was expected, the price and volume of alternate crpytocurencies are mostly correlated with the price of Bitcoin. I'm going to remove the highest correlations—LTC.Price, BTC.Volume and ETH.Price—and re-run the model
```{r}
coins_cor <- coins[, c(2, 5, 7, 8, 9)]
chart.Correlation(coins_cor)
```
The XRP.Price and XRP.Volume variables are slightly above 0.4 but they are close enough so we'll keep them.
## Create a Regression Model
```{r}
coin_reg <- lm(coins$BTC.Price ~ coins$ETH.Volume + coins$LTC.Volume + coins$XRP.Price + coins$XRP.Volume)
summary(coin_reg)
```
Let's remove ETH.Volume given it's P Value is well above 0.05
```{r}
coin_reg <- lm(coins$BTC.Price ~ + coins$LTC.Volume + coins$XRP.Price + coins$XRP.Volume)
summary(coin_reg)
```
The R-Squared is too low to provide an accurate prediction
# Predicting Tomorrow's Price Using a Series of Asset Class Prices

## Normalize the Data
```{r}
coins$BTC.Price <- (coins$BTC.Price - mean(coins$BTC.Price)) / sd(coins$BTC.Price)
coins$BTC.Volume <- (coins$BTC.Volume - mean(coins$BTC.Volume)) / sd(coins$BTC.Volume)
coins$ETH.Price <- (coins$ETH.Price - mean(coins$ETH.Price)) / sd(coins$ETH.Price)
coins$ETH.Volume <- (coins$ETH.Volume - mean(coins$ETH.Volume)) / sd(coins$ETH.Volume)
coins$LTC.Price <- (coins$LTC.Price - mean(coins$LTC.Price)) / sd(coins$LTC.Price)
coins$LTC.Volume <- (coins$LTC.Volume - mean(coins$LTC.Volume)) / sd(coins$LTC.Volume)
coins$XRP.Price <- (coins$XRP.Price - mean(coins$XRP.Price)) / sd(coins$XRP.Price)
coins$XRP.Volume <- (coins$XRP.Volume - mean(coins$XRP.Volume)) / sd(coins$XRP.Volume)
head(coins)
```


# Compare With Traditional Investment Vehichles (Equities & bonds)
(representde by the Dow jones and US treasury bonds)

*Evaluate Bitcoin Price Compared to the Top 5 Currencies*
```{r}
#plot_top_5_currencies()
```








### Display Large Scatter Plots
```{r}
# Map the correlation between Bitcoin's closing price and volume traded (in USD)
#plot(btc$Price, btc$Volume.USD, main = 'Price to Volume (USD) Comparison', xlab = 'Closing Price', ylab = 'Volume (USD)')
```
```{r}
# Map the correlation between Bitcoin's closing price and volume traded (in BTC)
#plot(btc$Price, btc$Volume.BTC, main = 'Price to Volume (BTC) Comparison', xlab = 'Closing Price', ylab = 'Volume (BTC)')
```
